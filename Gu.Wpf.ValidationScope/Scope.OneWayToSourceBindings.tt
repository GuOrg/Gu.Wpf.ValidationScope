<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".generated.cs" #>
namespace Gu.Wpf.ValidationScope
{
    using System;
    using System.Collections.ObjectModel;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Data;

    public static partial class Scope
    {
        private static readonly Binding BindingNotSet = new Binding { Mode = BindingMode.OneWayToSource };

<#
    var properties = new[]
                           {
                               new PropertyMetaData("HasError", "bool"), 
                               new PropertyMetaData("Errors", "ReadOnlyObservableCollection<ValidationError>"), 
                               new PropertyMetaData("Node", "IErrorNode"), 
                           };
	foreach(var property in properties)
	{
		 #>
        public static readonly DependencyProperty <#= property.Name #>BindingProperty = DependencyProperty.RegisterAttached(
            "<#= property.Name #>Binding",
            typeof(Binding),
            typeof(Scope),
            new PropertyMetadata(BindingNotSet, On<#= property.Name #>BindingChanged, On<#= property.Name #>BindingCoerce),
            OnValidateOneWayToSourceBinding);

<#
	}
	foreach(var property in properties)
	{
		 #>
        private static readonly DependencyProperty <#= property.Name #>ProxyProperty = DependencyProperty.RegisterAttached(
            "<#= property.Name #>Proxy",
            typeof(<#= property.Type #>),
            typeof(Scope),
            new PropertyMetadata(default(<#= property.Type #>)));

<#
	}

	foreach(var property in properties)
	{
		 #>
        [AttachedPropertyBrowsableForChildren(IncludeDescendants = false)]
        [AttachedPropertyBrowsableForType(typeof(UIElement))]
        public static Binding Get<#= property.Name #>Binding(this UIElement element) => (Binding)element.GetValue(<#= property.Name #>BindingProperty);

        public static void Set<#= property.Name #>Binding(this UIElement element, Binding value) => element.SetValue(<#= property.Name #>BindingProperty, value);

<#
	}

	foreach(var property in properties)
	{
		 #>
        private static void On<#= property.Name #>BindingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            BindingOperations.ClearBinding(d, <#= property.Name #>ProxyProperty);
            if (e.NewValue != null && e.NewValue != BindingNotSet)
            {
                BindingOperations.SetBinding(d, <#= property.Name #>ProxyProperty, (Binding)e.NewValue);
            }
        }

<#
	}

	
	foreach(var property in properties)
	{
		 #>
        private static object On<#= property.Name #>BindingCoerce(DependencyObject d, object basevalue)
        {
            if (basevalue != BindingNotSet && basevalue is Binding)
            {
                return basevalue;
            }

            var binding = BindingOperations.GetBinding(d, <#= property.Name #>BindingProperty);
            if (binding == null)
            {
                return null;
            }

            if (binding.Mode == BindingMode.Default)
            {
                binding = binding.Clone(BindingMode.OneWayToSource);
            }

            if (binding.Mode != BindingMode.OneWayToSource)
            {
                if (Is.DesignMode)
                {
                    throw new ArgumentException("Binding.Mode for <#= property.Name #>Binding must be BindingMode.OneWayToSource");
                }
            }

            d.SetValue(<#= property.Name #>BindingProperty, binding);
            return binding;
        }

<#
	}
		#>
        private static bool OnValidateOneWayToSourceBinding(object value)
        {
            if (value == null)
            {
                return true;
            }

            if ((value as Binding)?.Mode != BindingMode.OneWayToSource)
            {
                return false;
            }

            return true;
        }
    }
}
<#+

    private void WriteLineIfNotLast<T>(T item, IEnumerable<T> items)
		where T : class 
    {
        if (!ReferenceEquals(items.Last(), item))
        {
            this.WriteLine("");
        }
    }

    private class PropertyMetaData 
    {
        public readonly string Name;

        public readonly string Type;

        public PropertyMetaData(string name, string type)
        {
            this.Name = name;
            this.Type = type;
        }
    }
#>
